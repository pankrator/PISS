# Увод

Транзакциите са операции, които се извършват или от край до край, или не се извършват
въобще. Проблема е, че това трябва да се случи едновременно на всички сървъри,
изпълняващи програмата.

Транзакциите се делят на два вида:
- вложени - съдържат подтранзакции в себе си
- плоски - не съдържат подтранзакции

Транзакциите се управляват от координатор - това е мозъка на цялата операция.
Като минимум, координатора предоставя тия  методи:

```java
TID openTransaction(); // TID = Transaction IDentifier

// Няма нужда да се подава TID, не можеш да започнеш
// втора транзакция, докато тече текущата (за вложени ще говорим след малко)
void closeTransaction();

// Включва дадения participant (разбирай сървър
// или друго устройство към транзакцията)
void join(TID, Participant);
```

Когато транзакцията се опита да използва отдалечен обект, който се намира
на сървъра X, X е задължен да викне join(tid, X) на координатора. Така
координаторът знае, с които точно сървъри трябва да си говори, за да се случи
магията.


# Плоски транзакции

## Еднофазов протокол (1PC = 1 phase commit)

### Алгоритъм

1. Клиентът иска транзакция.
2. Координаторът заповядва на сървърите да си свършат работата.
3. Координаторът чака потвърждение от сървърите.
4. Край.

### Недостатъци

1. Супер тъп е - отделните сървъри не могат да върнат грешка, приема се,
че те ще успеят и само клиентът може да откаже транзакцията.

## Двуфазов протокол (2PC)

### Алгоритъм

1. Клиентът иска транзакция.
1. Координаторът заповядва на сървърите да си свършат работата.
  - Вика метода `canCommit` (виж долу за подробности)
1. Координаторът чака потвърждение от сървърите.
1. Сървърите казват "ДА, МИНАВА" или "НЕ, МАЙНАТА ? НА ТАЯ ЗАЯВКА".
1. Ако получи поне едно "не", координаторът отхвърля транзакцията, иначе я приема.
  - Ако получи не - координаторът вика `doAbort` на всички, които са *гласували с да*
(няма нужда да го вика на отхвърлилите)
  - Ако получи само "да" - координаторът вика `doCommit` на всички
1. Когато сървърите получат окончателното решение, изпълняват транзакцията или я заебават
в зависимост от него и изпращат потвърждение.
  - Ако е изпълнена, сървърите връщат `haveCommited`.
1. Координаторът чака потвърждето на всички.
1. Край.

Състояние на неопределеност - ако връзката или координатора се разпаднат,
сървърите няма да научат какво е окончателното решение. Затова изпращат
`getDecision` до координатора и искат повторно известие за решението.
Ако то не дойде в рамките на N време, отхвърлят транзакцията.

### Проблеми

1. Какво правим ако ни падне сървъра и потвърждениета не се върнат?
  - Срив на процес
  - Срив на връзка
  - Загуба на пакет

### Скучни подробности

Дефинираме следните методи:

```java
// Координаторът пита участник (т.е. сървър) дали е готов
boolean canCommit(TID);

// Координаторът съобщава на участник, че всички други са наред и може да завърши транзакцията
void doCommit(TID);

// Координаторът съобщава на участник, че някой от другите е преебал работата и транзакцията се отхвърля
void doAbort(TID);

// Координаторът пита участник дали е готов.
boolean haveCommited(TID);

// Участник пита координатора какво е решението; ползва се, когато участника не получи решението
// за някакво време (примерно връзката е временно прекъснала)
boolean getDecision(TID);
```

### Сложност

Пращат се поне 3 заявки за всеки сървър -> сложността е `O(3n)`.

# Вложени транзакции

...prepare your butthole

Добавяме методи на координатора:

```java
// Започва подтранзакция
TID openSubtransaction(TID);

// Връща текущия статус на транзакцията или подтранзакцията
// Статусите са 3 - commited (приета), aborted (отхвърлена), provisional (приета, но е само временна т.е. подтранзакция е)
Status getStatus(TID);
```

Допълваме горния алгоритъм с няколко забележки:

1. Ако подтранзакция се отхвърли, това не означава, че родителската транзакцията
също трябва да бъде отхвърлена.
1. Ако родителската се отхвърли, това означава, че всички нейни деца трябва да бъдат
отхвърлени.

Имаме варианта за разширяване на алгоритъма от по-горе.

## Йерархични вложени транзакции

Всяка подтранзакция получава собствен координатор.
Координаторът на най-високо ниво се допитва до координаторите на по-ниските нива,
които се държат идентично с алгоритъма по-горе т.е. просто викаме рекурсивно същата
функция.

## Плоски вложени транзакции

Вместо да се викат рекурсивно нови координатори, координаторът на най-високо ниво
си остава единствен и придобива задължението да си говори с всички негови наследници (подтранзакции).
Метода `canCommit` получава допълнителен аргумент

```java
// aborted съдържа всички вече отхвърлени подтранзакции
// Задължение на всяка подтранзакция е да се самоотхвърли ако открие, че нейния
// родител вече е бил добавен в тая колекция.
boolean canCommit(TID, ArrayList<TID> aborted);
```
