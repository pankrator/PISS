# Увод

Транзакциите са операции, които се извършват или от край до край, или не се извършват
въобще. Проблема е, че това трябва да се случи едновременно на всички сървъри,
изпълняващи програмата.

Транзакциите се делят на два вида:
- вложени - съдържат подтранзакции в себе си
- плоски - не съдържат подтранзакции

Транзакциите се управляват от координатор - това е мозъка на цялата операция.
Като минимум, координатора предоставя тия  методи:

```java
TID openTransaction(); // TID = Transaction IDentifier

// Няма нужда да се подава TID, не можеш да започнеш
// втора транзакция, докато тече текущата (за вложени ще говорим след малко)
void closeTransaction();

// Включва дадения participant (разбирай сървър
// или друго устройство към транзакцията)
void join(TID, Participant);
```

Когато транзакцията се опита да използва отдалечен обект, който се намира
на сървъра X, X е задължен да викне join(tid, X) на координатора. Така
координаторът знае, с които точно сървъри трябва да си говори, за да се случи
магията.


# Плоски транзакции

## Еднофазов протокол (1PC = 1 phase commit)

### Алгоритъм

1. Клиентът иска транзакция.
2. Координаторът заповядва на сървърите да си свършат работата.
3. Координаторът чака потвърждение от сървърите.
4. Край.

### Недостатъци

1. Супер тъп е - отделните сървъри не могат да върнат грешка, приема се,
че те ще успеят и само клиентът може да откаже транзакцията.

## Двуфазов протокол (2PC)

### Алгоритъм

1. Клиентът иска транзакция.
1. Координаторът заповядва на сървърите да си свършат работата.
  - Вика метода `canCommit` (виж долу за подробности)
1. Координаторът чака потвърждение от сървърите.
1. Сървърите казват "ДА, МИНАВА" или "НЕ, МАЙНАТА ? НА ТАЯ ЗАЯВКА".
1. Ако получи поне едно "не", координаторът отхвърля транзакцията, иначе я приема.
  - Ако получи не - координаторът вика `doAbort` на всички, които са *гласували с да*
(няма нужда да го вика на отхвърлилите)
  - Ако получи само "да" - координаторът вика `doCommit` на всички
1. Когато сървърите получат окончателното решение, изпълняват транзакцията или я заебават
в зависимост от него и изпращат потвърждение.
  - Ако е изпълнена, сървърите връщат `haveCommited`.
1. Координаторът чака потвърждето на всички.
1. Край.

Състояние на неопределеност - ако връзката или координатора се разпаднат,
сървърите няма да научат какво е окончателното решение. Затова изпращат
`getDecision` до координатора и искат повторно известие за решението.
Ако то не дойде в рамките на N време, отхвърлят транзакцията.

### Проблеми

1. Какво правим ако ни падне сървъра и потвърждениета не се върнат?
  - Срив на процес
  - Срив на връзка
  - Загуба на пакет

### Скучни подробности

Дефинираме следните методи:

```java
// Координаторът пита участник (т.е. сървър) дали е готов
boolean canCommit(TID);

// Координаторът съобщава на участник, че всички други са наред и може да завърши транзакцията
void doCommit(TID);

// Координаторът съобщава на участник, че някой от другите е преебал работата и транзакцията се отхвърля
void doAbort(TID);

// Координаторът пита участник дали е готов.
boolean haveCommited(TID);

// Участник пита координатора какво е решението; ползва се, когато участника не получи решението
// за някакво време (примерно връзката е временно прекъснала)
boolean getDecision(TID);
```

### Сложност

Пращат се поне 3 заявки за всеки сървър -> сложността е `O(3n)`.

# Вложени транзакции

...prepare your butthole

Добавяме методи на координатора:

```java
// Започва подтранзакция
TID openSubtransaction(TID);

// Връща текущия статус на транзакцията или подтранзакцията
// Статусите са 3 - commited (приета), aborted (отхвърлена), provisional (приета, но е само временна т.е. подтранзакция е)
Status getStatus(TID);
```

To be continued...