Като споделяме ресурси ще ни трябва синхронизация между
сървърите.

# Оптимистично управление

Правим се, че ресурса не е споделен:

1. Работна фаза: всеки сървър работи върху собственото си копие на обекта.
2. Фаза на валидация: проверяваме дали има конфликти между работата на сървърите.
3. Фаза на обновяване: ако няма конфликти - записваме резултата и сме готови.
Ако има...prepare your butthole.

## Правила за валидация

За да няма конфликти следните правила не трябва да бъдат нарушавани:

| ТV | Ti | Правило | Описание |
| -- | -- | ------- | -------- |
| Writе | Read | 1 Ti не трябва да чете обекти записани от Tv |
| Read | Write | 2 | Tv не трябва да чете обекти записани от Ti |
| Write | Write | 3 | Ti не трябва да записва обекти записани от Tv и Tv не трябва да записва обекти записани от Ti |

Правила 1 и 2 са еднакви, но с размени роли, сърдете се на лекциите.

# Справяне с мъртви хватки (deadlocks)

Няма нужда да обяснявам какво е deadlock, нали?

## Глобален Wait-for graph

Правим граф, чиито възли са транзакции и обекти, а ребрата показват, коя транзакция 
кой е заключила и кой обект чака.

Правим по един такъв локален граф на всеки сървър и проверяваме за цикли в графа.
Ако има - има мъртва хватка. Ако няма го прехвърляме на координатора.

Координаторът създава глобален граф, използвайки всички локали и
проверява дали има цикли в графа - ако да, има мъртва хватка.

Тоя подход е смотан, защото изисква много допълнителна работа - прехвърлянето на графа,
конструирането на глобалния. Освен това има възможност да даде false positives и да се опита
да развърже несъществуваща мъртва хватка (понеже може състоянието на транзакциите да се смени
докато графите се прехвърлят на координатора).

## Съседски wait-for graph

Вместо да пазим всичко в координатора, правим дистрибутиран граф.

Нека транзакция T чака транзакция U, която е блокирана:

1. Сървърът изпраща съобщението `<T -> U>` на машината, която държи U.
1. Получателя на съобщението проверява какво U чака (да кажем, че U чака V)
и добавя V в съобщението: `<Т -> U -> V>`.
1. Проверяваме дали в съобщението има цикли.
  1. Ако има, разплитаме ги.
  1. Ако няма, изпращаме съобщениетп до машината, която държи V и повтаряме стъпка 2.

### Ефективност

За N транзакции трябва `O(2N - 2)` съобщения.

В реалния свят, мървтвите хватки почти винаги са само от 2 транзакции, така че
това не е проблем.

## Приоритети на транзакциите

Даваме на всяка транзакция приоритет. Ако се случи мървтва хватка, при която
транзакция i да чака j и `i > j`, прекъсваме j и освобождаваме ресурсите ѝ.

В тоя случай можем да намалим условието за хватка, като препращаме само случаите,
в които `i > j` (иначе няма да може да се случи хватка). Това обаче създава възможност
да изтървем някоя истинска мъртва хватка, заради проблеми с времето и се налага допълнително
пазене на копия на съобщенията за съседския граф. Виж слайд 36 от темата за транзакции.

# Възстановяване на транзакциите

Как си оправяме бакиите ако сме ги счупили?

Вкарваме нов компонент - мениджър за възстановяване. Мениджъра прави магията си
посредством файл за възстановяване, който може да е различни видове.
За сега, мениджъра започва да пази следните списъци:

1. Списък на сървър - текущо активните транзакции
1. Списък на транзакция - съдържа промените направени от транзакцията

След изпълнението на всяка транзакция, я записваме в така наречения лог -
той е просто списък от списъци на всички транзакции.

## Възстановяване на обекти от списък

1. Тръгваме от края на списъка
  - За всяка транзакция след търсената намираме последната, която е променила
данните, която текущата е пипала и ги връщаме

ИЛИ

1. Тръгваме от началното състояние
  - Изпълняваме транзакциите една след друга, докато не стигнем търсената.
  
## Преорганизиране на файла

Ако се налага пипаме по файла за възстановяване, за да го направим по-хубав -
оправяме му прическата и грима, създаваме checkpoints, маркери.

## Възстановяване на дистрибутирани транзакции

Ако искаме да погрижим и за дистрибутираните транзакции (не само за единични обекти, както горе)
в линейния списък почваме да записваме и състоянието на неопределеност, в която всеки сървър може
да попадне ако падне връзката. Така симулираме истинската работа на системата. Виж слайдове 44-46.

## Възстановяване от склад за версии

Вместо да пазим линеен списък от транзакции, пазим всички обекти въобще в речник,
например хештаблица. С други думи, правим snapshot на системата. Като ни трябва да върнем
транзакция я издирваме и презаписваме всички стойности както са били по нейно време.
